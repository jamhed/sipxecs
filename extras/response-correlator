#! /usr/bin/perl

# Correlate requests and responses in proxy log.

# Find all incoming requests and outgoing responses that were the 1st
# leg (direct from the phone).  Correlate request, 1st (non-100)
# provisional response, and final response.

# Get arguments.
# --csv means to generate output in CSV format.
# --all means to report on all transactions, not just the ones with one Via.
# --ignore-date means to ignore the Date: header inserted by the UAC (in case
#       it is incorrect).
while (1) {
    if ($ARGV[0] eq '--csv') {
	$csv = 1;
	shift @ARGV;
    } elsif ($ARGV[0] eq '--all') {
	$all_transactions = 1;
	shift @ARGV;
    } elsif ($ARGV[0] eq '--ignore-date') {
	$ignore_date = 1;
	shift @ARGV;
    } else {
	last;
    }
}

$= = 1_000_000;

$first_line = 1;
while (<>) {
    # If this is the first line, check its format.
    if ($first_line) {
	$first_line = 0;

	if (!/^"20\d\d-\d\d-\d\dT\d\d:\d\d:\d\d[.\d]*Z":\d+:/) {
	    print STDERR "Are you sure this is a sipX log file?  The first line has incorrect syntax:\n";
	    print STDERR "\t", $_;
	}
    }
    if (($method, $uri) = /:INCOMING:.*---- Port:[ \d]*----\\n([A-Z0-9]+) ((sips?:|UNKNOWN|tel:)[^ ]*)/) {
	# Incoming request.
	if ($all_transactions || !/branch=.*branch=/) {
	    # Get the branch parameter of the first Via.
	    ($time, $branch) = m/^"...........(...............).*?branch=([^\\;]*)/; #";
	    if (!$ignore_date) {
		($date) = m/\\nDate: *([^\\]*)/i;
		($date) = $date =~ m/(\d\d:\d\d:\d\d)/;
	    } else {
		$date = '';
	    }
            # Mark the branch specially if this is a CANCEL.
            $branch .= ' ' if /\\ncseq: *\d* *cancel/i;
            $sortdate = $date ne '' ? $date : $time;
	    $sortdate{$branch} = $sortdate unless defined($sortdate{$branch}) && $sortdate{$branch} lt $sortdate;
	    if (!(defined($reqtime{$branch}) && $reqtime{$branch} lt $time)) {
                if ($method eq 'SUBSCRIBE' || $method eq 'NOTIFY') {
		    # For SUBSCRIBE or NOTIFY, use as the method "Sxx" or "Nxx",
		    # where "xx" is the first two letters of the event-type.
	            ($event) = m/\\nEvent: *([^\\;]*)/i;
                    $method = substr($method, 0, 1) . substr($event . '  ', 0, 2);
                } elsif ($method eq 'REGISTER') {
		    # For REGISTER, use the To-URI instead of the rquest-URI,
		    # as it includes the user-part.
		    my ($u, $v);
		    ($u) = m/\\nTo: *(([^\\]|\\")*)/i;
		    ($v) = $u =~ m/<(.*)>/;
		    $uri =
			$v ne '' ? $v :
			$u ne '' ? $u :
			$uri;
                }
                $uri =~ s/^sips?://i;
                $req = substr($method, 0, 3) . ' ' . $uri;
	        $req{$branch} = $req;
                # The request may have been seen as incoming in the log of a different process.
		if (!(defined($reqtime{$branch}) && $reqtime{$branch} lt $time)) {
	            $reqtime{$branch} = $time;
                    $reqdate{$branch} = $date;
                }
            }
	}
    } elsif (($response) = /:OUTGOING:.*----\\nSIP\/2\.0 (\d\d\d) /) {
	# Outgoing response.
        # Exclude 100 responses, and ones with multiple Via's.
	if ($response ne '100' && ($all_transactions || !/branch=.*branch=/)) {
	    # Get the branch parameter of the first Via.
	    ($time, $branch) = m/^"...........(...............).*?branch=([^\\;]*)/; #";
	    ($date) = m/\\nDate: *([^\\]*)/i;
            # Mark the branch specially if this is a CANCEL.
            $branch .= ' ' if /\\ncseq: *\d* *cancel/i;
	    $sortdate{$branch} = $time unless defined($sortdate{$branch}) && $sortdate{$branch} lt $time;
            if (substr($response, 0, 1) eq '1') {
		# Provisional response.
		if (!(defined($provtime{$branch}) && $provtime{$branch} lt $time)) {
		    $prov{$branch} = $response;
		    $provtime{$branch} = $time;
		    $provdate{$branch} = $date;
		}
	    } else {
		# Final response.
	        if (!(defined($resptime{$branch}) && $resptime{$branch} lt $time)) {
		    $resp{$branch} = $response;
		    $resptime{$branch} = $time;
		    $respdate{$branch} = $date;
		}
	    }
	}
    }
}

if ($csv) {
    print "\"Branch\",\"Sort time\",\"First time\",\"Request time\",",
          "\"Request received\",\"Provisional response\",\"Provisional sent\",",
          "\"Final response\",\"Final sent\",",
          "\"Method\",\"Request URI\"",
          "\n";
}
foreach $branch (sort { $sortdate{$a} cmp $sortdate{$b} } keys(%sortdate)) {
    my($i, $first_time);
    # @times is global so the format can see it.
    # Get the times for the request.
    @times = ($reqdate{$branch},
	      $reqtime{$branch},
	      $provtime{$branch},
	      $resptime{$branch});
    @print_times = ();
    # Change all but the first into relative times.
    $first_time = undef;
    #print "A", join('|', @times), "\n";
    for ($i = 0; $i <= $#times; $i++) {
	if ($times[$i]) {
	    if (defined($first_time)) {
		$print_times[$i] = &tdiff($times[$i], $first_time);
	    } else {
		$first_time = $times[$i];
		$print_times[$i] = $times[$i];
	    }
	}
    }
    #print "B", join('|', @times), "\n";
    if ($csv) {
	$method = substr($req{$branch}, 0, 3);
	$uri = substr($req{$branch}, 4);
	print &quote(substr($branch, 0, 7) eq 'z9hG4bK' ? substr($branch, 7) : $branch), ',',
	      &quote($sortdate{$branch}), ',',
	      &quote($first_time), ',', &quote($times[0]), ',',
	      &quote($times[1]), ',',
	      &quote($prov{$branch}), ',', &quote($times[2]), ',',
	      &quote($resp{$branch}), ',', &quote($times[3]), ',',
	      &quote($method), ',', &quote($uri),
	      "\n";
    } else {
	write STDOUT;
    }
}

format STDOUT_TOP =
Branch     Request   Request   Provisional   Final         Method
z9hG4bK+   sent      received      sent          sent          Req-URI sip(s):+

.

format STDOUT =
@<<<<<<<<  @<<<<<<<  @<<<<<<<  @>> @<<<<<<<  @>> @<<<<<<<  @<<<<<<<<<<<<<<<<<<<<
{ substr($branch, 0, 7) eq 'z9hG4bK' ? substr($branch, 7) : $branch,
           $print_times[0],
		     $print_times[1],
			       $prov{$branch}, $print_times[2],
					     $resp{$branch}, $print_times[3],
							   $req{$branch} }
.

# Calculate the difference between two times.
sub tdiff {
    my($time, $base) = @_;

    return '' if $time eq '';
    return $time if $base eq '';
    {
	my($a, $b, $c, $times, $bases);

	($a, $b, $c) = split(/:/, $time);
	$times = 3600 * $a + 60 * $b + $c;
	($a, $b, $c) = split(/:/, $base);
	$bases = 3600 * $a + 60 * $b + $c;
	$times = $times - $bases;
	return 
	    $times == 0 ? ' 0' :
	    $times < 0 ? $times . '' :
	    '+' . $times;
    }
}

# Quote a value to appear in a CSV file.
sub quote {
    my($arg) = @_;
    $arg =~ s/"/""/g; #";
    $arg = '"' . $arg . '"';
}
